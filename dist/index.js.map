{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": [
    "import net from \"node:net\";\nimport tls from \"node:tls\";\nimport { createHash } from \"node:crypto\";\n\n// ------------------ Result Pattern Types ------------------\n\n/**\n * A discriminated union type representing the result of an operation.\n * \n * This pattern allows for explicit error handling without throwing exceptions.\n * All async operations return a Result object, allowing callers to decide how to handle success and failure.\n * \n * @template T - The type of data returned on success\n * \n * @example\n * ```ts\n * const result = await client.runCommand(\"/system/identity/print\");\n * if (!result.status) {\n *   console.log('something wrong happened ->', result.message);\n *   console.log('error ->', result.error); // actual error object\n * } else {\n *   console.log('everything went well ->', result.data);\n * }\n * ```\n */\nexport type Result<T> =\n\t| { status: true; data: T }\n\t| { status: false; message: string; error?: unknown };\n\n// ------------------ Event Emitter ------------------\n\n/**\n * Creates a simple event emitter with functional API.\n * \n * @returns An emitter object with methods to manage event listeners\n * \n * @example\n * ```ts\n * const emitter = createEmitter();\n * \n * emitter.on(\"data\", (value) => console.log(value));\n * emitter.emit(\"data\", 42); // logs: 42\n * ```\n */\nexport function createEmitter() {\n\tconst listeners = new Map<string, Set<(...args: unknown[]) => void>>();\n\n\tfunction on(event: string, fn: (...args: unknown[]) => void) {\n\t\tlet set = listeners.get(event);\n\t\tif (!set) {\n\t\t\tset = new Set();\n\t\t\tlisteners.set(event, set);\n\t\t}\n\t\tset.add(fn);\n\t\treturn emitter;\n\t}\n\n\tfunction once(event: string, fn: (...args: unknown[]) => void) {\n\t\tconst wrapper = (...args: unknown[]) => {\n\t\t\toff(event, wrapper);\n\t\t\tfn(...args);\n\t\t};\n\t\treturn on(event, wrapper);\n\t}\n\n\tfunction off(event: string, fn: (...args: unknown[]) => void) {\n\t\tconst set = listeners.get(event);\n\t\tif (set) {\n\t\t\tset.delete(fn);\n\t\t\tif (set.size === 0) listeners.delete(event);\n\t\t}\n\t\treturn emitter;\n\t}\n\n\tfunction emit(event: string, ...args: unknown[]) {\n\t\tconst set = listeners.get(event);\n\t\tif (set) for (const fn of set) fn(...args);\n\t}\n\n\tconst emitter = { on, once, off, emit };\n\treturn emitter;\n}\n\n// ------------------ Types ------------------\n\ntype RouterOSResponse = Record<string, string>;\n\n/**\n * Configuration options for creating a RouterOS client connection.\n * \n * @example\n * ```ts\n * const client = createRouterOSClient({\n *   host: \"192.168.88.1\",\n *   ssl: false,\n *   timeout: 15000\n * });\n * ```\n */\nexport interface RouterOSClientOptions {\n\t/**\n\t * Router IP address or hostname (required).\n\t * @example \"192.168.88.1\" or \"router.example.com\"\n\t */\n\thost: string;\n\t\n\t/**\n\t * Port number for the connection.\n\t * Defaults to 8728 for TCP or 8729 for SSL.\n\t */\n\tport?: number;\n\t\n\t/**\n\t * Enable TLS/SSL connection.\n\t * When true, uses port 8729 by default.\n\t * RouterOS uses self-signed certificates by default.\n\t * @default false\n\t */\n\tssl?: boolean;\n\t\n\t/**\n\t * Connection attempt timeout in milliseconds.\n\t * @default 30000\n\t */\n\ttimeout?: number;\n}\n\n// ------------------ Encoding / Decoding helpers ------------------\n\nfunction concatUint8Arrays(arrays: Uint8Array[]): Uint8Array {\n\tlet totalLength = 0;\n\tfor (const arr of arrays) totalLength += arr.length;\n\tconst result = new Uint8Array(totalLength);\n\tlet offset = 0;\n\tfor (const arr of arrays) {\n\t\tresult.set(arr, offset);\n\t\toffset += arr.length;\n\t}\n\treturn result;\n}\n\nfunction encodeLength(len: number): Uint8Array {\n\tif (len < 0x80) return new Uint8Array([len]);\n\tif (len < 0x4000) return new Uint8Array([(len >> 8) | 0x80, len & 0xff]);\n\tif (len < 0x200000)\n\t\treturn new Uint8Array([(len >> 16) | 0xc0, (len >> 8) & 0xff, len & 0xff]);\n\tif (len < 0x10000000)\n\t\treturn new Uint8Array([\n\t\t\t(len >> 24) | 0xe0,\n\t\t\t(len >> 16) & 0xff,\n\t\t\t(len >> 8) & 0xff,\n\t\t\tlen & 0xff,\n\t\t]);\n\treturn new Uint8Array([\n\t\t0xf0,\n\t\t(len >> 24) & 0xff,\n\t\t(len >> 16) & 0xff,\n\t\t(len >> 8) & 0xff,\n\t\tlen & 0xff,\n\t]);\n}\n\nfunction encodeWord(word: string): Uint8Array {\n\tconst encoder = new TextEncoder();\n\tconst wordBuf = encoder.encode(word);\n\tconst lenBuf = encodeLength(wordBuf.length);\n\treturn concatUint8Arrays([lenBuf, wordBuf]);\n}\n\nfunction decodeLength(\n\tbuffer: Uint8Array,\n\toffset = 0,\n): { length: number; bytes: number } | null {\n\tif (offset >= buffer.length) return null;\n\tconst first = buffer[offset];\n\tif (!first || first === 0) return { length: 0, bytes: 1 };\n\tif ((first & 0x80) === 0) return { length: first, bytes: 1 };\n\tif ((first & 0xc0) === 0x80)\n\t\treturn {\n\t\t\tlength: ((first & 0x3f) << 8) | (buffer[offset + 1] ?? 0),\n\t\t\tbytes: 2,\n\t\t};\n\tif ((first & 0xe0) === 0xc0)\n\t\treturn {\n\t\t\tlength:\n\t\t\t\t((first & 0x1f) << 16) |\n\t\t\t\t((buffer[offset + 1] ?? 0) << 8) |\n\t\t\t\t(buffer[offset + 2] ?? 0),\n\t\t\tbytes: 3,\n\t\t};\n\tif ((first & 0xf0) === 0xe0)\n\t\treturn {\n\t\t\tlength:\n\t\t\t\t((first & 0x0f) << 24) |\n\t\t\t\t((buffer[offset + 1] ?? 0) << 16) |\n\t\t\t\t((buffer[offset + 2] ?? 0) << 8) |\n\t\t\t\t(buffer[offset + 3] ?? 0),\n\t\t\tbytes: 4,\n\t\t};\n\tif (first === 0xf0)\n\t\treturn {\n\t\t\tlength:\n\t\t\t\t((buffer[offset + 1] ?? 0) << 24) |\n\t\t\t\t((buffer[offset + 2] ?? 0) << 16) |\n\t\t\t\t((buffer[offset + 3] ?? 0) << 8) |\n\t\t\t\t(buffer[offset + 4] ?? 0),\n\t\t\tbytes: 5,\n\t\t};\n\treturn null;\n}\n\nfunction parseSentences(buffer: Uint8Array): {\n\tsentences: string[][];\n\trest: Uint8Array;\n} {\n\tconst sentences: string[][] = [];\n\tlet offset = 0;\n\tconst decoder = new TextDecoder();\n\twhile (offset < buffer.length) {\n\t\tconst sentence: string[] = [];\n\t\twhile (offset < buffer.length) {\n\t\t\tconst lenInfo = decodeLength(buffer, offset);\n\t\t\tif (!lenInfo) return { sentences, rest: buffer.slice(offset) };\n\t\t\toffset += lenInfo.bytes;\n\t\t\tif (lenInfo.length === 0) break;\n\t\t\tif (offset + lenInfo.length > buffer.length)\n\t\t\t\treturn { sentences, rest: buffer.slice(offset - lenInfo.bytes) };\n\t\t\tconst word = decoder.decode(\n\t\t\t\tbuffer.slice(offset, offset + lenInfo.length),\n\t\t\t);\n\t\t\tsentence.push(word);\n\t\t\toffset += lenInfo.length;\n\t\t}\n\t\tif (sentence.length > 0) sentences.push(sentence);\n\t}\n\treturn { sentences, rest: new Uint8Array(0) };\n}\n\nfunction toObjects(sentences: string[][]): RouterOSResponse[] {\n\treturn sentences\n\t\t.filter((s) => s[0] === \"!re\")\n\t\t.map((s) =>\n\t\t\ts.slice(1).reduce<RouterOSResponse>((acc, item) => {\n\t\t\t\tif (item.startsWith(\"=\")) {\n\t\t\t\t\tconst [k, ...v] = item.slice(1).split(\"=\");\n\t\t\t\t\tif (typeof k !== \"undefined\") acc[k] = v.join(\"=\");\n\t\t\t\t}\n\t\t\t\treturn acc;\n\t\t\t}, {}),\n\t\t);\n}\n\n// ------------------ Factory client ------------------\n\n/**\n * Creates a RouterOS API client instance bound to a single RouterOS host.\n * \n * Provides a minimal, functional API for connecting, authenticating, and executing\n * commands on MikroTik RouterOS devices. All async operations return a Result object\n * for explicit error handling without throwing exceptions.\n * \n * @param options - Configuration options for the client\n * @returns A client object with methods for connecting, authenticating, and executing commands\n * \n * @example\n * ```ts\n * import { createRouterOSClient } from \"ts-router-os\";\n * \n * const client = createRouterOSClient({\n *   host: \"192.168.88.1\",\n *   ssl: false,\n *   timeout: 15000\n * });\n * \n * // Connect to the router\n * const connected = await client.connect();\n * if (!connected.status) return console.error(connected.message);\n * \n * // Authenticate\n * const auth = await client.login(\"admin\", \"password\");\n * if (!auth.status) return console.error(auth.message);\n * \n * // Execute commands\n * const list = await client.runCommand(\"/interface/print\");\n * if (list.status) {\n *   console.log('Interfaces:', list.data);\n * }\n * \n * // Clean up\n * client.close();\n * ```\n */\nexport function createRouterOSClient(options: RouterOSClientOptions) {\n\tlet socket: net.Socket | tls.TLSSocket | null = null;\n\tconst events = createEmitter();\n\n\t/**\n\t * Opens a TCP or TLS socket connection to the RouterOS device.\n\t * \n\t * Must be called before `login` or any command execution.\n\t * Uses the port, SSL, and timeout settings from the client options.\n\t * \n\t * @returns A Result indicating connection success or failure\n\t * \n\t * @example\n\t * ```ts\n\t * const connected = await client.connect();\n\t * if (!connected.status) {\n\t *   console.error(\"Failed to connect:\", connected.message);\n\t *   return;\n\t * }\n\t * console.log(\"Connected successfully!\");\n\t * ```\n\t */\n\tasync function connect(): Promise<Result<void>> {\n\t\tconst { host, port, ssl, timeout } = {\n\t\t\tport: options.ssl ? 8729 : 8728,\n\t\t\ttimeout: 30000,\n\t\t\tssl: false,\n\t\t\t...options,\n\t\t};\n\n\t\ttry {\n\t\t\tawait new Promise<void>((resolve, reject) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst s = ssl\n\t\t\t\t\t\t? tls.connect({ host, port, timeout }, () => resolve())\n\t\t\t\t\t\t: net.connect({ host, port, timeout }, () => resolve());\n\n\t\t\t\t\tsocket = s;\n\t\t\t\t\ts.on(\"connect\", () => events.emit(\"connect\"));\n\t\t\t\t\ts.on(\"error\", (err) => {\n\t\t\t\t\t\tevents.emit(\"error\", err);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t});\n\t\t\t\t\ts.on(\"close\", () => events.emit(\"close\"));\n\t\t\t\t\ts.on(\"end\", () => events.emit(\"end\"));\n\t\t\t\t} catch (err) {\n\t\t\t\t\tevents.emit(\"error\", err);\n\t\t\t\t\treject(err);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn { status: true, data: undefined };\n\t\t} catch (err) {\n\t\t\treturn {\n\t\t\t\tstatus: false,\n\t\t\t\tmessage: `Failed to connect to ${host}:${port}: ${(err as Error).message}`,\n\t\t\t\terror: err,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Authenticates with the RouterOS device using username and password.\n\t * \n\t * Automatically handles both legacy and challenge-based authentication flows.\n\t * The connection must be established via `connect()` before calling this method.\n\t * Most RouterOS commands require authentication.\n\t * \n\t * @param user - RouterOS username (e.g., \"admin\")\n\t * @param password - RouterOS password for the user\n\t * @returns A Result indicating authentication success or failure\n\t * \n\t * @example\n\t * ```ts\n\t * const auth = await client.login(\"admin\", \"mypassword\");\n\t * if (!auth.status) {\n\t *   console.error(\"Login failed:\", auth.message);\n\t *   return;\n\t * }\n\t * console.log(\"Authenticated successfully!\");\n\t * ```\n\t */\n\tasync function login(user: string, password: string): Promise<Result<void>> {\n\t\ttry {\n\t\t\tconst reply = await runCommand(\"/login\", { name: user, password });\n\t\t\tif (!reply.status) {\n\t\t\t\tconst { message, error } = reply as { status: false; message: string; error?: unknown };\n\t\t\t\treturn { status: false, message, error };\n\t\t\t}\n\n\t\t\tconst ret = reply.data\n\t\t\t\t.flatMap((r) => Object.entries(r))\n\t\t\t\t.find(([k]) => k === \"ret\")?.[1];\n\n\t\t\tif (ret) {\n\t\t\t\tconst challenge = new Uint8Array(\n\t\t\t\t\tret.match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16)) || [],\n\t\t\t\t);\n\t\t\t\tconst passwordBytes = new TextEncoder().encode(password);\n\t\t\t\tconst data = new Uint8Array(1 + passwordBytes.length + challenge.length);\n\t\t\t\tdata.set([0], 0);\n\t\t\t\tdata.set(passwordBytes, 1);\n\t\t\t\tdata.set(challenge, 1 + passwordBytes.length);\n\t\t\t\tconst digest = createHash(\"md5\").update(Buffer.from(data)).digest();\n\t\t\t\tconst response =\n\t\t\t\t\t\"00\" +\n\t\t\t\t\tArray.from(digest)\n\t\t\t\t\t\t.map((b: number) => b.toString(16).padStart(2, \"0\"))\n\t\t\t\t\t\t.join(\"\");\n\t\t\t\tconst finalLoginRes = await runCommand(\"/login\", { name: user, response });\n\t\t\t\tif (!finalLoginRes.status) {\n\t\t\t\t\tconst { message, error } = finalLoginRes as { status: false; message: string; error?: unknown };\n\t\t\t\t\treturn { status: false, message, error };\n\t\t\t\t}\n\t\t\t\treturn { status: true, data: undefined };\n\t\t\t}\n\t\t\treturn { status: true, data: undefined };\n\t\t} catch (err) {\n\t\t\treturn {\n\t\t\t\tstatus: false,\n\t\t\t\tmessage: `Login failed: ${(err as Error).message}`,\n\t\t\t\terror: err,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Executes a RouterOS API command and returns the response data.\n\t * \n\t * This is the core method for interacting with the RouterOS API. Commands use\n\t * the RouterOS path format (e.g., `/interface/print`, `/ip/address/add`).\n\t * \n\t * Parameters are passed as key-value pairs. Keys starting with `?` are used\n\t * for filtering/querying. Regular keys are used for setting values.\n\t * \n\t * @param cmd - The RouterOS API command path (e.g., \"/interface/print\")\n\t * @param params - Key-value pairs for command parameters and filters\n\t * @returns A Result containing an array of response objects from RouterOS\n\t * \n\t * @example\n\t * ```ts\n\t * // List all interfaces\n\t * const interfaces = await client.runCommand(\"/interface/print\");\n\t * if (interfaces.status) {\n\t *   console.log(interfaces.data); // Array of interface objects\n\t * }\n\t * \n\t * // Add a new IP address\n\t * const add = await client.runCommand(\"/ip/address/add\", {\n\t *   address: \"192.168.1.1/24\",\n\t *   interface: \"ether1\"\n\t * });\n\t * \n\t * // Query with filters (keys starting with ?)\n\t * const filtered = await client.runCommand(\"/interface/print\", {\n\t *   \"?type\": \"ether\"\n\t * });\n\t * ```\n\t */\n\tfunction runCommand(\n\t\tcmd: string,\n\t\tparams: Record<string, string> = {},\n\t): Promise<Result<RouterOSResponse[]>> {\n\t\tif (!socket) {\n\t\t\treturn Promise.resolve({\n\t\t\t\tstatus: false,\n\t\t\t\tmessage: \"Not connected\",\n\t\t\t});\n\t\t}\n\n\t\treturn new Promise((resolve) => {\n\t\t\tconst s = socket as net.Socket;\n\t\t\tconst parts = [\n\t\t\t\tcmd,\n\t\t\t\t...Object.entries(params).map(([k, v]) => `=${k}=${v}`),\n\t\t\t];\n\t\t\tconst data = concatUint8Arrays([\n\t\t\t\t...parts.map(encodeWord),\n\t\t\t\tnew Uint8Array([0]),\n\t\t\t]);\n\n\t\t\tconst responses: string[][] = [];\n\t\t\tlet readBuffer: Uint8Array = new Uint8Array(0);\n\n\t\t\tconst onData = (chunk: Buffer) => {\n\t\t\t\tconst chunkData = new Uint8Array(chunk);\n\t\t\t\treadBuffer = concatUint8Arrays([readBuffer, chunkData]);\n\t\t\t\tconst { sentences, rest } = parseSentences(readBuffer);\n\t\t\t\treadBuffer = new Uint8Array(rest);\n\t\t\t\tfor (const sent of sentences) {\n\t\t\t\t\tif (sent[0] === \"!trap\") {\n\t\t\t\t\t\tcleanup();\n\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\tstatus: false,\n\t\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\t\tsent.find((x) => x.startsWith(\"=message=\"))?.slice(9) ??\n\t\t\t\t\t\t\t\t\"Trap error\",\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (sent[0] === \"!fatal\") {\n\t\t\t\t\t\tcleanup();\n\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\tstatus: false,\n\t\t\t\t\t\t\tmessage: \"Fatal error: \" + sent.slice(1).join(\" \"),\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresponses.push(sent);\n\t\t\t\t\tif (sent[0] === \"!done\") {\n\t\t\t\t\t\tcleanup();\n\t\t\t\t\t\tresolve({ status: true, data: toObjects(responses) });\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst onError = (err: Error) => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve({ status: false, message: err.message, error: err });\n\t\t\t};\n\t\t\tconst onClose = () => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve({ status: false, message: \"Connection closed\" });\n\t\t\t};\n\t\t\tconst onEnd = () => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve({ status: false, message: \"Connection ended\" });\n\t\t\t};\n\n\t\t\tfunction cleanup() {\n\t\t\t\ts.off(\"data\", onData);\n\t\t\t\ts.off(\"error\", onError);\n\t\t\t\ts.off(\"close\", onClose);\n\t\t\t\ts.off(\"end\", onEnd);\n\t\t\t}\n\n\t\t\ts.on(\"data\", onData);\n\t\t\ts.on(\"error\", onError);\n\t\t\ts.on(\"close\", onClose);\n\t\t\ts.on(\"end\", onEnd);\n\n\t\t\ts.write(Buffer.from(data));\n\t\t});\n\t}\n\n\t/**\n\t * Closes the connection to the RouterOS device and cleans up resources.\n\t * \n\t * Destroys the underlying socket connection. This method is synchronous\n\t * and should be called when you're done using the client.\n\t * \n\t * @returns A Result indicating whether the close operation succeeded\n\t * \n\t * @example\n\t * ```ts\n\t * // When done with the client\n\t * const result = client.close();\n\t * if (!result.status) {\n\t *   console.error(\"Failed to close connection:\", result.message);\n\t * }\n\t * ```\n\t */\n\tfunction close(): Result<void> {\n\t\ttry {\n\t\t\tsocket?.destroy();\n\t\t\tevents.emit(\"close\");\n\t\t\treturn { status: true, data: undefined };\n\t\t} catch (err) {\n\t\t\tevents.emit(\"error\", err);\n\t\t\treturn {\n\t\t\t\tstatus: false,\n\t\t\t\tmessage: (err as Error).message,\n\t\t\t\terror: err,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn {\n\t\t/**\n\t\t * Opens a TCP or TLS socket connection to the RouterOS device.\n\t\t * \n\t\t * Must be called before `login` or any command execution.\n\t\t * Uses the port, SSL, and timeout settings from the client options.\n\t\t * \n\t\t * @returns A Result indicating connection success or failure\n\t\t * \n\t\t * @example\n\t\t * ```ts\n\t\t * const connected = await client.connect();\n\t\t * if (!connected.status) {\n\t\t *   console.error(\"Failed to connect:\", connected.message);\n\t\t *   return;\n\t\t * }\n\t\t * console.log(\"Connected successfully!\");\n\t\t * ```\n\t\t */\n\t\tconnect,\n\t\t/**\n\t\t * Authenticates with the RouterOS device using username and password.\n\t\t * \n\t\t * Automatically handles both legacy and challenge-based authentication flows.\n\t\t * The connection must be established via `connect()` before calling this method.\n\t\t * Most RouterOS commands require authentication.\n\t\t * \n\t\t * @param user - RouterOS username (e.g., \"admin\")\n\t\t * @param password - RouterOS password for the user\n\t\t * @returns A Result indicating authentication success or failure\n\t\t * \n\t\t * @example\n\t\t * ```ts\n\t\t * const auth = await client.login(\"admin\", \"mypassword\");\n\t\t * if (!auth.status) {\n\t\t *   console.error(\"Login failed:\", auth.message);\n\t\t *   return;\n\t\t * }\n\t\t * console.log(\"Authenticated successfully!\");\n\t\t * ```\n\t\t */\n\t\tlogin,\n\t\t/**\n\t\t * Executes a RouterOS API command and returns the response data.\n\t\t * \n\t\t * This is the core method for interacting with the RouterOS API. Commands use\n\t\t * the RouterOS path format (e.g., `/interface/print`, `/ip/address/add`).\n\t\t * \n\t\t * Parameters are passed as key-value pairs. Keys starting with `?` are used\n\t\t * for filtering/querying. Regular keys are used for setting values.\n\t\t * \n\t\t * @param cmd - The RouterOS API command path (e.g., \"/interface/print\")\n\t\t * @param params - Key-value pairs for command parameters and filters\n\t\t * @returns A Result containing an array of response objects from RouterOS\n\t\t * \n\t\t * @example\n\t\t * ```ts\n\t\t * // List all interfaces\n\t\t * const interfaces = await client.runCommand(\"/interface/print\");\n\t\t * if (interfaces.status) {\n\t\t *   console.log(interfaces.data); // Array of interface objects\n\t\t * }\n\t\t * \n\t\t * // Add a new IP address\n\t\t * const add = await client.runCommand(\"/ip/address/add\", {\n\t\t *   address: \"192.168.1.1/24\",\n\t\t *   interface: \"ether1\"\n\t\t * });\n\t\t * \n\t\t * // Query with filters (keys starting with ?)\n\t\t * const filtered = await client.runCommand(\"/interface/print\", {\n\t\t *   \"?type\": \"ether\"\n\t\t * });\n\t\t * ```\n\t\t */\n\t\trunCommand,\n\t\t/**\n\t\t * Closes the connection to the RouterOS device and cleans up resources.\n\t\t * \n\t\t * Destroys the underlying socket connection. This method is synchronous\n\t\t * and should be called when you're done using the client.\n\t\t * \n\t\t * @returns A Result indicating whether the close operation succeeded\n\t\t * \n\t\t * @example\n\t\t * ```ts\n\t\t * // When done with the client\n\t\t * const result = client.close();\n\t\t * if (!result.status) {\n\t\t *   console.error(\"Failed to close connection:\", result.message);\n\t\t * }\n\t\t * ```\n\t\t */\n\t\tclose,\n\t\t/**\n\t\t * Registers an event listener that will be called every time the specified event is emitted.\n\t\t * \n\t\t * Available events:\n\t\t * - `error`: Emitted when a connection error occurs\n\t\t * - `close`: Emitted when the connection is closed\n\t\t * - `end`: Emitted when the connection ends\n\t\t * - `connect`: Emitted when successfully connected\n\t\t * \n\t\t * @param event - The event name to listen for\n\t\t * @param fn - The callback function to execute when the event is emitted\n\t\t * @returns The client object for method chaining\n\t\t * \n\t\t * @example\n\t\t * ```ts\n\t\t * client.on(\"error\", (err) => {\n\t\t *   console.error(\"Connection error:\", err);\n\t\t * });\n\t\t * \n\t\t * client.on(\"close\", () => {\n\t\t *   console.log(\"Connection closed\");\n\t\t * });\n\t\t * ```\n\t\t */\n\t\ton: events.on.bind(events),\n\t\t/**\n\t\t * Registers a one-time event listener that will be called only once when the specified event is emitted.\n\t\t * After being called once, the listener is automatically removed.\n\t\t * \n\t\t * Available events:\n\t\t * - `error`: Emitted when a connection error occurs\n\t\t * - `close`: Emitted when the connection is closed\n\t\t * - `end`: Emitted when the connection ends\n\t\t * - `connect`: Emitted when successfully connected\n\t\t * \n\t\t * @param event - The event name to listen for\n\t\t * @param fn - The callback function to execute once when the event is emitted\n\t\t * @returns The client object for method chaining\n\t\t * \n\t\t * @example\n\t\t * ```ts\n\t\t * client.once(\"connect\", () => {\n\t\t *   console.log(\"Connected! This will only log once.\");\n\t\t * });\n\t\t * ```\n\t\t */\n\t\tonce: events.once.bind(events),\n\t\t/**\n\t\t * Removes a previously registered event listener.\n\t\t * \n\t\t * @param event - The event name to remove the listener from\n\t\t * @param fn - The specific callback function to remove\n\t\t * @returns The client object for method chaining\n\t\t * \n\t\t * @example\n\t\t * ```ts\n\t\t * const errorHandler = (err) => console.error(err);\n\t\t * client.on(\"error\", errorHandler);\n\t\t * \n\t\t * // Later, remove the listener\n\t\t * client.off(\"error\", errorHandler);\n\t\t * ```\n\t\t */\n\t\toff: events.off.bind(events),\n\t\t/**\n\t\t * Convenience method to retrieve the router's system identity.\n\t\t * \n\t\t * This is equivalent to calling `runCommand(\"/system/identity/print\")`.\n\t\t * Returns information about the router's configured name and identity.\n\t\t * \n\t\t * @returns A Result containing the system identity data\n\t\t * \n\t\t * @example\n\t\t * ```ts\n\t\t * const identity = await client.getSystemIdentity();\n\t\t * if (identity.status) {\n\t\t *   console.log(\"Router name:\", identity.data[0]?.name);\n\t\t * }\n\t\t * ```\n\t\t */\n\t\tgetSystemIdentity() {\n\t\t\treturn runCommand(\"/system/identity/print\");\n\t\t},\n\t};\n}\n"
  ],
  "mappings": "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",
  "debugId": "FB6DE6DFF84CEEAB64756E2164756E21",
  "names": []
}